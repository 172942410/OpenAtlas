//
// ReportDisconnectedRegions
//   Usage: ReportDisconnectedRegions CubesModel LabelLUT
//          where
//          CubesModel is a .vtk model generated by GenerateCubesFromLabnels
//          LabelLUT is the label lookup file
//      
//
#include <vtksys/SystemTools.hxx>

#include <vtkPolyDataConnectivityFilter.h>
#include <vtkPolyDataReader.h>
#include <vtkCleanPolyData.h>
#include <vtkSmartPointer.h>
#include <vtkTriangleFilter.h>
#include <vtkMassProperties.h>
#include <vtkFieldData.h>

#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>

int main (int argc, char *argv[])
{
  if (argc < 3)
    {
    std::cout << "Usage: " << argv[0] << " CubesModel FiducialDirectory" << std::endl;
    return EXIT_FAILURE;
    }
 
  std::string fiducialDirectory(argv[2]);
  vtksys::SystemTools::MakeDirectory(argv[2]);

  // Create all of the classes we will need
  vtkSmartPointer<vtkPolyDataReader> reader =
    vtkSmartPointer<vtkPolyDataReader>::New();
  vtkSmartPointer<vtkPolyDataConnectivityFilter> confilter =
    vtkSmartPointer<vtkPolyDataConnectivityFilter>::New();

  reader->SetFileName(argv[1]);
  reader->Update();
  double voxelVolume = 1.0;
  double hasSpacing = false; // does the polydata field data define spacing

  if (reader->GetOutput()->GetFieldData())
    {
    if (reader->GetOutput()->GetFieldData()->GetArray("Spacing"))
      {
      double spacing[3];
      reader->GetOutput()->GetFieldData()->GetArray("Spacing")->GetTuple(0, spacing);
      voxelVolume = spacing[0] * spacing[1] * spacing[2];
      hasSpacing = true;
      }
    }
  confilter->SetInputConnection(reader->GetOutputPort());
  confilter->SetExtractionModeToLargestRegion();
  confilter->Update();
  if (confilter->GetNumberOfExtractedRegions() > 1)
    {
    std::cout << "WARNING: " 
              << vtksys::SystemTools::GetFilenameName(std::string(argv[1]))
              << " has "
              << confilter->GetNumberOfExtractedRegions()
              << " disconnected regions" << std::endl;
    // create a list of fiducials
    std::string anatomyName = vtksys::SystemTools::GetFilenameWithoutExtension(std::string(argv[1]));
    std::stringstream fiducialFileName;
    fiducialFileName << fiducialDirectory << "/"
                     << anatomyName
                     << ".csv";
    std::ofstream fout(fiducialFileName.str().c_str());
    if (fout.fail())
      {
      std::cout << "cannot open " << fiducialFileName.str() << std::endl;
      return EXIT_FAILURE;
      }
    // header
    fout << "# Markups fiducial file version = 4.4" << std::endl;
    fout << "# CoordinateSystem = 0" << std::endl;
    fout << "# columns = id,x,y,z,ow,ox,oy,oz,vis,sel,lock,label,desc,associatedNodeID" << std::endl;

    vtkSmartPointer<vtkCleanPolyData> cleaner =
      vtkSmartPointer<vtkCleanPolyData>::New();
    cleaner->SetInputConnection( confilter->GetOutputPort());
    cleaner->Update();
    int sizeOfLargestRegion = cleaner->GetOutput()->GetNumberOfPoints();

    vtkSmartPointer<vtkTriangleFilter> triangles =
      vtkSmartPointer<vtkTriangleFilter>::New();
    triangles->SetInputConnection(cleaner->GetOutputPort());
    vtkSmartPointer<vtkMassProperties> massProp =
      vtkSmartPointer<vtkMassProperties>::New();
    massProp->SetInputConnection(triangles->GetOutputPort());

    // Make a pass through all of the regions to get the number of
    // points in each region
    std::vector<std::pair<int,int> > regions;

    for (int i = 1; i < confilter->GetNumberOfExtractedRegions(); ++i)
      {
      confilter->SetExtractionModeToSpecifiedRegions();
      confilter->InitializeSpecifiedRegionList();
      confilter->AddSpecifiedRegion(i);
      cleaner->Update();
      double volume = massProp->GetVolume();
      int sizeOfThisRegion = cleaner->GetOutput()->GetNumberOfPoints();
      std::pair<int,int> regionPair;
      if (hasSpacing)
        {
        regionPair = std::make_pair(volume / voxelVolume, i);
        }
      else
        {
        regionPair = std::make_pair(sizeOfThisRegion, i);
        }
      regions.push_back(regionPair);
      }

    // Sort the regions by size of region
    std::sort(regions.begin(), regions.end());
    
    // Skip the first region
    for (size_t r = 0; r < regions.size(); ++r)
      {
      int i = regions[r].second;
      confilter->SetExtractionModeToSpecifiedRegions();
      confilter->InitializeSpecifiedRegionList();
      confilter->AddSpecifiedRegion(i);
      cleaner->Update();
      int sizeOfThisRegion = cleaner->GetOutput()->GetNumberOfPoints();
      if (hasSpacing)
        {
        std::cout << "Region " << i << " has " << regions[r].first << " voxels" << std::endl;
        }
      else
        {
        std::cout << "Region " << i << " has " << sizeOfThisRegion << " points" << std::endl;
        }

      // Mark regions that are within 50% of the size of the largest region
      std::string description;
      float percentOfLargest = (float) sizeOfThisRegion / (float) sizeOfLargestRegion;
      if (percentOfLargest > 0.50)
        {
        std::cout << "Region " << i
                  << " is large. Size is " <<  percentOfLargest * 100.0 << " percent of largest." << std::endl;
        std::stringstream percentDescription;
        percentDescription << "Large disconnected region(" << percentOfLargest * 100.0 << "%)";
        description = percentDescription.str();
        }
      else if (sizeOfThisRegion == 8)
        {
        description = "Single disconnected voxel";
        }
      else
        {
        std::stringstream percentDescription;
        if (hasSpacing)
          {
          percentDescription << "Disconnected region(" << regions[r].first << " voxels)";
          }
        else
          {
          percentDescription << "Disconnected region(" << percentOfLargest * 100.0 << "%)";
          }
        description = percentDescription.str();
        }
      double centroid[3];
      int mid = 0;
      centroid[0] = cleaner->GetOutput()->GetPoints()->GetPoint(mid)[0];
      centroid[1] = cleaner->GetOutput()->GetPoints()->GetPoint(mid)[1];
      centroid[2] = cleaner->GetOutput()->GetPoints()->GetPoint(mid)[2];
      std::stringstream fiducialName;
      fiducialName << vtksys::SystemTools::GetFilenameWithoutExtension(std::string(argv[1]))
                   << "_" << i;
      fout << "vtkMRMLMarkupsFiducialNode_" << anatomyName << "," // id
           << centroid[0] << "," << centroid[1] << "," << centroid[2] << "," // x,y,z
           << "0," // ows
           << "0," // ox
           << "0," // oy
           << "1," // oz
           << "0," // vis
           << "1," // sel
           << "1," // lock
           << fiducialName.str() << ","
           << "" << description << "," // description
           << "vtkMRMLScalarVolumeNode2"
           << std::endl;
      }
    fout.close();
    std::stringstream mrmlFileName;
    mrmlFileName << fiducialDirectory << "/"
                     << anatomyName
                     << ".mrml";
    std::ofstream mout(mrmlFileName.str().c_str());
    mout << "<MRML  version=\"Slicer4.4.0\" userTags=\"\">" << std::endl;
    mout << " <MarkupsFiducial";
    mout << " id=\"vtkMRMLMarkupsFiducialNode_" << anatomyName << "\""
         << " name=\"" << anatomyName << "\""
         << " hideFromEditors=\"false\"  selectable=\"true\"  selected=\"false\"  displayNodeRef=\"vtkMRMLMarkupsDisplayNodeOpenAtlas\""
         << " storageNodeRef=\"vtkMRMLMarkupsFiducialStorageNode_" << anatomyName << "\""
         << " userTags=\"\"  locked=\"0\"  markupLabelFormat=\"%N-%d\" ></MarkupsFiducial>" << std::endl;
    mout << " <MarkupsFiducialStorage";
    mout << " id=\"vtkMRMLMarkupsFiducialStorageNode_" << anatomyName << "\""
         << " name=\"" << "MarkupsFiducialStorage_" << anatomyName << "\""
         << " hideFromEditors=\"true\"  selectable=\"true\"  selected=\"false\" "
         << " fileName=\"" << fiducialFileName.str() << "\""
         << " useCompression=\"1\" readState=\"0\" writeState=\"4\" coordinateSystem=\"0\" >"
         << "</MarkupsFiducialStorage>" << std::endl;
    mout << "</MRML>" << std::endl;
    mout.close();
    return EXIT_FAILURE;
    }
  return EXIT_SUCCESS;
}
